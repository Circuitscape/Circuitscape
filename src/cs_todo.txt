# Fixme: place -2 in resistances for included pairs

        # 
# #        	Graph.write_adjacency('filename')
#       	Graph.Read_adjacency('filename')
#         test =   Graph.Read_ncol('graph_ncol.txt')
# #     def writeGraph(self,G):
#         numnodes = G.shape[0]
#         graphList = []
#         for i in range(0,numnodes-1)
#             for j in range(i+1,numnodes)
#                 if G[i,j]>0:
#                  resistances = insert(resistances, [0], 0, axis = 0)
#                     x = x+1
#                     graphList[x,1] = i+1
#                     graphList[x,2] = j+1
#                 
#         node1 = graphList[:,0]
#         node2 = graphList[:,1]
#         data = graphList[:,2]
# 
#         savetxt ('graph_written.txt', graphList)



# todo: warning if header of mask file is different specifies mask file
# advanced- test with source ground files
#tests for all applicable cases?

# for now, assume one component
# include/exclude NO
# strengths YES
# reclass? Yes
# write currents and voltages
# write version#

#VERIFY
# single
# single, exclude
# one
# all, exclude, varsrc
# adv
# adv, rmvsrc
# adv rmvgrnd
# adv rmvall
#reclass for regular verify

#test shortcut resistances
#auto detect ascii grids

#test header check code

#drop current in polygons?
#get unique node numbers, (node_map == value).sum()
#create a reclass table to create a node map that has number of times a node is in the map.  Divide current by that. Zero out voltage dropes when n>1.
#percentile maps?
#voltage drop


#VOLTAGE DROP- right now it's the literal voltage drop.  Should amend to max i*r, and only use when average resistances?  That way drop happens in cell responsible for it, not spread across barrier and adhacent cells.

#NODATA for currents when input hab map=nodata NO NEED?  0 is valid
#NODATA for voltages when g=0  DO NEED.  Voltage is undefined

# incomplete resistances can slow down!
#add incomplete r's to pairwise network